virtualenv circuitBenv
---------------------
circuitBenv\scripts\activate
set SERVICE_PATH=D:\SERVICES\API-Gateway
--------------
pip install git+https://github.com/achalbante/CircuitBreakerLib.git



==============documents=======
https://bhaveshpraveen.medium.com/implementing-circuit-breaker-pattern-from-scratch-in-python-714100cdf90b
https://hackernoon.com/circuit-breakers-in-microservices-els3tv1
========================================================================================================

States:

Closed: 
    Normal state. Requests pass through as usual. Failures are counted.

Open: 
    Too many failures occurred. Requests are blocked immediately, preventing further load on the failing service.

Half-Open: 
    After a cooldown period, a limited number of trial requests are allowed.

    If they succeed → circuit goes back to Closed.

    If they fail → circuit goes back to Open.

Failure Threshold:
    Defines how many failures within a certain time window will cause the breaker to open.

Reset Timeout:
    How long the breaker stays open before moving to half-open and allowing test requests.
-------------------------------------------------------------
Imagine your service calls a payment gateway API:

If the auth-service is down and every request fails, your app would keep retrying and eventually crash or slow down.
With a circuit breaker:
After, say, 5 failures in 30 seconds, the breaker opens.
Your app immediately fails requests (fast failure) instead of waiting on timeouts.
After a minute, it tries a few requests in half-open state. If they succeed → resume normal operation.

____________________________
pip install PyYAML




1. failure_threshold: 3

If 3 failures happen within the last 30 seconds (window_seconds), the circuit moves to OPEN.

2. recovery_timeout: 10

Once the circuit is OPEN, it stays OPEN (all calls blocked) for 10 seconds.

After 10 seconds, it transitions to HALF_OPEN.

3. half_open_max_calls: 1

In HALF_OPEN, only 1 trial call is allowed.

If that succeeds → circuit goes back to CLOSED (normal state).

If that fails → circuit goes back to OPEN again.

4. window_seconds: 30

This is not a nap time.
It’s the look-back window for counting failures.

Example:

Call fails at t=0s

Call fails at t=10s

Call fails at t=20s → That’s 3 failures within 30s → circuit goes OPEN.

At t=40s, the first failure (at t=0) is expired from the sliding window. So now only the failures at t=10s and t=20s count.

==============================================================================

API Call → Check Service Port
    if port down → force OPEN all APIs → raise CircuitOpenError-> take recovery_timeout after check ->half_open_max_calls
    if port up → proceed

API Call → Check API-level circuit
    if port run → the check api working or not 
    if API OPEN & recovery_timeout not passed → raise CircuitOpenError
    if API OPEN & recovery_timeout passed → HALF_OPEN → allow probe
    if API CLOSED → proceed


Port down → all APIs blocked until recovery_timeout.

Port up → working APIs proceed.

API failures → open only that API, others unaffected.

HALF_OPEN allows limited retries.

=======================
Service port check happens first, all APIs under the service OPEN if port is down.

API-level failures affect only that API, other APIs remain functional.

HALF_OPEN allows limited probes after recovery_timeout.

Working APIs continue to run, even if another API is OPEN.

Recovery timeout applies separately per API.